C51 COMPILER V9.54   END                                                                   11/20/2025 22:14:14 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE END
OBJECT MODULE PLACED IN .\Objects\end.obj
COMPILER INVOKED BY: d:\Keil_v5\C51\BIN\C51.EXE end.c OPTIMIZE(0,SIZE) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\end.ls
                    -t) TABS(2) OBJECT(.\Objects\end.obj)

line level    source

   1          #include"STC89C52RC.h"
   2          #include <string.h>
   3          #include <stdio.h>
   4          #include <intrins.h>
   5          #define uint unsigned int
   6          #define uchar unsigned char
   7          
   8          struct DHTResult{
   9            int errornum;
  10            uchar rec_buffer[5];
  11          };
  12          
  13          //write
  14          sbit led0=P1^0;
  15          sbit led1=P1^1;
  16          sbit led2=P1^2;
  17          sbit led3=P1^3;
  18          sbit led4=P1^4;
  19          //sbit led5=P1^5;
  20          //sbit led6=P1^6;
  21          //sbit led7=P1^7;
  22          sbit trig=P1^5;
  23          sbit echo=P1^6;
  24          sbit DHT11_IO=P1^7;
  25          
  26          sbit lcden=P3^4;
  27          sbit lcdrs=P3^5;
  28          sbit rw=P3^6;
  29          
  30          sbit xinghao=P2^0;
  31          sbit S5=P2^5;
  32          sbit dula=P2^6;
  33          sbit wela=P2^7;
  34          
  35          
  36          int trigNum;
  37          volatile uint t;
  38          uint mult;
  39          struct DHTResult rst = {0,{0,0,0,0,0}};
  40          volatile uchar DHT11_read_byte();
  41          int time;
  42          uint time1;
  43          uint clock;
  44          uint LEDSwitch;
  45          uint moshi;
  46          uint DCA;
  47          //uint timekeeping;
  48          //delay
  49          void delay_ms(uint z){
  50   1        volatile uint x,y;
  51   1          for(x=z;x>0;x--)
  52   1              for(y=120;y>0;y--);
  53   1      }
  54          void delay_us(uint z){
C51 COMPILER V9.54   END                                                                   11/20/2025 22:14:14 PAGE 2   

  55   1        while(z--);
  56   1      }
  57          //display
  58          void write_com(uchar com){
  59   1        lcdrs=0;
  60   1        rw=0;
  61   1        P0=com;
  62   1        delay_ms(5);
  63   1        lcden=1;
  64   1        delay_ms(5);
  65   1        lcden=0;
  66   1      }
  67          
  68          void write_data(uchar date){
  69   1        lcdrs=1;
  70   1        rw=0;
  71   1        P0=date;
  72   1        delay_ms(5);
  73   1        lcden=1;
  74   1        delay_ms(5);
  75   1        lcden=0;
  76   1      }
  77          void show(uchar *str){
  78   1        while(*str)
  79   1          write_data(*str++);
  80   1      }
  81          //init
  82          void init(){
  83   1        led0=0;
  84   1        led1=0;
  85   1        led2=0;
  86   1        led3=0;
  87   1      //  led4=0;
  88   1        mult=0;
  89   1        //LCD
  90   1        delay_ms(1000);
  91   1        dula=0;
  92   1        wela=0;
  93   1        lcden=0;
  94   1        delay_ms(20);
  95   1        write_com(0x38);
  96   1        write_com(0x0C);
  97   1        write_com(0x06);
  98   1        write_com(0x80);
  99   1        write_com(0x80);
 100   1          write_data('O');
 101   1          write_data('K');
 102   1        //DHT11
 103   1        t=0;
 104   1        
 105   1        //PWM
 106   1        trigNum=0;
 107   1        LEDSwitch=1;
 108   1        time=0;
 109   1        time1=0;
 110   1        clock=0;
 111   1        TMOD&=0x00;
 112   1        TMOD|=0x11;
 113   1        //1ms/time
 114   1        TL0 = 0x48;
 115   1        TH0 = 0xFF;   
 116   1        //50ms/time
C51 COMPILER V9.54   END                                                                   11/20/2025 22:14:14 PAGE 3   

 117   1        TL1 = 0x00;
 118   1        TH1 = 0x4C;
 119   1        EA=1;
 120   1        ET0=1;
 121   1        ET1=1;
 122   1      }
 123          //DHT11
 124          int DHT11_start() {
 125   1        t=0;
 126   1        DHT11_IO = 1;
 127   1        //start
 128   1        DHT11_IO = 0;
 129   1        while(t<1700)
 130   1          t+=1;
 131   1        DHT11_IO=1;
 132   1        //respond
 133   1        //wait start
 134   1        while(DHT11_IO!=0);
 135   1        //wait 83us
 136   1        while(DHT11_IO==0);
 137   1        //wait 87us
 138   1        while(DHT11_IO==1);
 139   1        DHT11_read_byte();
 140   1        return 0;
 141   1      }
 142          volatile uchar DHT11_read_byte() {
 143   1        uchar i,j,k,dat=0;
 144   1        char buf[4];
 145   1        for(k=0;k<5;k++){
 146   2          for(j=0;j<8;j++){
 147   3            //skip 50us
 148   3            while(0==DHT11_IO);
 149   3            //delay 20us
 150   3            for(i=0;i<4;i++);
 151   3            if(DHT11_IO){
 152   4              dat=dat<<1;
 153   4              dat|=1;
 154   4              while(DHT11_IO);
 155   4            }
 156   3            else
 157   3              dat=dat<<1;
 158   3          }
 159   2          rst.rec_buffer[k]=dat;
 160   2          dat=0;
 161   2        }
 162   1        //panduan
 163   1        if(rst.rec_buffer[0]+rst.rec_buffer[1]+rst.rec_buffer[2]+rst.rec_buffer[3]==rst.rec_buffer[4]){
 164   2          write_com(0x80);
 165   2          write_data('H');
 166   2          write_data(':');
 167   2          buf[0]=rst.rec_buffer[0]/100+'0';
 168   2          buf[1]=(rst.rec_buffer[0]/10)%10+'0';
 169   2          buf[2]=rst.rec_buffer[0]%10+'0';
 170   2          buf[3]='\0';
 171   2          show(buf);
 172   2          write_data('.');
 173   2          buf[0]=rst.rec_buffer[1]/100+'0';
 174   2          buf[1]=(rst.rec_buffer[1]/10)%10+'0';
 175   2          buf[2]=rst.rec_buffer[1]%10+'0';
 176   2          buf[3]='\0';
 177   2          show(buf);
 178   2          write_com(0x80+0x40);
C51 COMPILER V9.54   END                                                                   11/20/2025 22:14:14 PAGE 4   

 179   2          write_data('T');
 180   2          write_data(':');
 181   2          buf[0]=rst.rec_buffer[2]/100+'0';
 182   2          buf[1]=(rst.rec_buffer[2]/10)%10+'0';
 183   2          buf[2]=rst.rec_buffer[2]%10+'0';
 184   2          buf[3]='\0';
 185   2          show(buf);
 186   2          write_data('.');
 187   2          buf[0]=rst.rec_buffer[3]/100+'0';
 188   2          buf[1]=(rst.rec_buffer[3]/10)%10+'0';
 189   2          buf[2]=rst.rec_buffer[3]%10+'0';
 190   2          buf[3]='\0';
 191   2          show(buf);
 192   2          delay_ms(1000);
 193   2        }
 194   1      //  else
 195   1      //    led2=0;
 196   1        while(DHT11_IO==0);
 197   1        return dat;
 198   1      }
 199          //PWM
 200          void ledpwm(){
 201   1        if(LEDSwitch==0){
 202   2          TR0=1;
 203   2          if(clock<100){
 204   3            if(clock<=time)
 205   3              led0=0;
 206   3            else
 207   3              led0=1;
 208   3          }
 209   2          else
 210   2            clock=0;
 211   2          //duty ratio
 212   2          if(DCA>=200){
 213   3            DCA=0;
 214   3            if(time>=95){
 215   4              time-=1;
 216   4              moshi=2;
 217   4            }
 218   3            else if(time<40){
 219   4              time+=1;
 220   4              moshi=1;
 221   4            }
 222   3            if(moshi==1/*&&mult>8*/){
 223   4              time+=1;
 224   4              mult=0;
 225   4            }
 226   3            else if(moshi==2/*&&mult>8*/){
 227   4              time-=1;
 228   4              mult=0;
 229   4            }
 230   3      //      mult++;
 231   3          }
 232   2        }
 233   1        else{
 234   2          TR1=1;
 235   2          led0=1;
 236   2          if(time1>=6){
 237   3            time1=0;
 238   3            TR1=0;
 239   3            led0=0;
 240   3          }
C51 COMPILER V9.54   END                                                                   11/20/2025 22:14:14 PAGE 5   

 241   2        }
 242   1      }
 243          //ultrasonicSensor
 244          int ultrasonicSensor(){
 245   1        int i,k;
 246   1        trigNum=0;
 247   1        for(i=0;i<1;i++){
 248   2          trig=1;
 249   2          _nop_();_nop_();_nop_();_nop_();
 250   2          _nop_();_nop_();_nop_();
 251   2          _nop_();_nop_();_nop_();_nop_();
 252   2          _nop_();_nop_();_nop_();_nop_();
 253   2          trig=0;
 254   2          _nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();
 255   2          delay_us(500);
 256   2          if(echo==0){
 257   3            trigNum+=1;
 258   3          }
 259   2          delay_ms(200);
 260   2        }
 261   1        if(trigNum==1)
 262   1          return 1;
 263   1        else
 264   1          return 0;
 265   1      }
*** WARNING C280 IN LINE 245 OF end.c: 'k': unreferenced local variable
 266          //keyscan
 267          int keyscan(){
 268   1        int k,cishu;
 269   1        if(S5==0){
 270   2          led3=1;
 271   2          cishu=0;
 272   2          delay_ms(20);
 273   2          if(S5==0){
 274   3            //0:short,1:long
 275   3            while(S5==0){
 276   4              for(k=0;k<9000;k++){
 277   5                if(S5==1&&cishu<6){
 278   6                  DHT11_start();
 279   6                  return 1;
 280   6                }
 281   5              }
 282   4              cishu+=1;
 283   4              led3=!led3;
 284   4            }
 285   3            if(LEDSwitch==0){
 286   4              LEDSwitch=1;
 287   4              return 2;
 288   4            }
 289   3            else{
 290   4              LEDSwitch=0;
 291   4              return 2;
 292   4            }
 293   3          }
 294   2          else
 295   2            return 0;
 296   2        }
 297   1        else{
 298   2          return 0;
 299   2        }
 300   1      }
 301          //main
C51 COMPILER V9.54   END                                                                   11/20/2025 22:14:14 PAGE 6   

 302          void main() {
 303   1        init();
 304   1        while(1){
 305   2          if(LEDSwitch==0){
 306   3            ledpwm();
 307   3          }
 308   2          else{
 309   3            trigNum=ultrasonicSensor();
 310   3            if(trigNum==1){
 311   4              trigNum=0;
 312   4                  time1=0;
 313   4              ledpwm();
 314   4            }
 315   3            else
 316   3              if(led0==1){
 317   4                if(time1>=60){
 318   5                  time1=0;
 319   5                  TR1=0;
 320   5                  led0=0;
 321   5                }
 322   4              }
 323   3          }
 324   2          keyscan();
 325   2        }
 326   1      }
 327          //interrupt
 328          void timer() interrupt 1{
 329   1        TL0 = 0x48;
 330   1        TH0 = 0xFF;   
 331   1        clock+=1;
 332   1        DCA+=1;
 333   1      }
 334          void timer1() interrupt 3{
 335   1        TL1 = 0x00;
 336   1        TH1 = 0x4C;
 337   1        time1+=1;
 338   1      }
*** WARNING C291 IN LINE 265 OF end.c: not every exit path returns a value
*** WARNING C291 IN LINE 300 OF end.c: not every exit path returns a value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1319    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     54    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
